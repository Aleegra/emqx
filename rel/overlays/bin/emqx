#!/bin/sh
set -e

SELF=$(readlink "$0" || true)
if [ -z "$SELF" ]; then SELF="$0"; fi
RELEASE_ROOT="$(CDPATH='' cd "$(dirname "$SELF")/.." && pwd -P)"
export RELEASE_ROOT
export RELEASE_NAME="${RELEASE_NAME:-"emqx"}"
export RELEASE_VSN="${RELEASE_VSN:-"$(cut -d' ' -f2 "$RELEASE_ROOT/releases/start_erl.data")"}"
export RELEASE_COMMAND="$1"
export RELEASE_MODE="${RELEASE_MODE:-"embedded"}"
export RELEASE_PROG="${RELEASE_PROG:-"$(echo "$0" | sed 's/.*\///')"}"

REL_VSN_DIR="$RELEASE_ROOT/releases/$RELEASE_VSN"
. "$REL_VSN_DIR/env.sh"
. "$RELEASE_ROOT/releases/emqx_vars"

export RELEASE_COOKIE="${RELEASE_COOKIE:-"$(cat "$RELEASE_ROOT/releases/COOKIE")"}"
export RELEASE_NODE="${RELEASE_NODE:-"$RELEASE_NAME"}"
export RELEASE_TMP="${RELEASE_TMP:-"$RELEASE_ROOT/tmp"}"
export RELEASE_VM_ARGS="${RELEASE_VM_ARGS:-"$REL_VSN_DIR/vm.args"}"
export RELEASE_REMOTE_VM_ARGS="${RELEASE_REMOTE_VM_ARGS:-"$REL_VSN_DIR/remote.vm.args"}"
export RELEASE_BOOT_SCRIPT="${RELEASE_BOOT_SCRIPT:-"start"}"
export RELEASE_BOOT_SCRIPT_CLEAN="${RELEASE_BOOT_SCRIPT_CLEAN:-"start_clean"}"
export RELEASE_SYS_CONFIG="${RELEASE_SYS_CONFIG:-"$REL_VSN_DIR/sys"}"

# defined in emqx_vars
export RUNNER_ROOT_DIR
export RUNNER_ETC_DIR
export ERTS_VSN

export SCHEMA_MOD=emqx_conf_schema
export CONFIGS_DIR="$RUNNER_DATA_DIR/configs"
export MNESIA_DATA_DIR="$RUNNER_DATA_DIR/mnesia"

set_name () {
  IS_BOOT_COMMAND='no'
  case "$1" in
    start|start_iex|daemon|daemon_iex)
      IS_BOOT_COMMAND='yes'
      ;;
  esac

  ## Possible ways to configure emqx node name:
  ## 1. configure node.name in emqx.conf
  ## 2. override with environment variable EMQX_NODE_NAME
  ## Node name is either short-name (without '@'), e.g. 'emqx'
  ## or long name (with '@') e.g. 'emqx@example.net' or 'emqx@127.0.0.1'
  NAME="${EMQX_NODE_NAME:-}"
  if [ -z "$NAME" ]; then
    if [ "$IS_BOOT_COMMAND" = 'yes' ]; then
      # for boot commands, inspect emqx.conf for node name
      NAME="$(call_hocon -s $SCHEMA_MOD -c $RUNNER_ETC_DIR/emqx.conf get node.name | tr -d \")"
    else
      # for non-boot commands, inspect vm.<time>.args for node name
      # shellcheck disable=SC2012,SC2086
      LATEST_VM_ARGS="$(ls -t $CONFIGS_DIR/vm.*.args | head -1)"
      NAME="$(grep -E '^-s?name' "$LATEST_VM_ARGS" | awk '{print $2}')"
    fi
  fi

  [ -z "$NAME" ] && NAME='emqx'

  case "$NAME" in
    *@*)
      NAME_TYPE='-name'
     ;;
    *)
      NAME_TYPE='-sname'
  esac
  SHORT_NAME="$(echo "$NAME" | awk -F'@' '{print $1}')"
  export ESCRIPT_NAME="$SHORT_NAME"

    export NAME_TYPE
    export NAME
}

SED_REPLACE="sed -i "
case $(sed --help 2>&1) in
    *GNU*) SED_REPLACE="sed -i ";;
    *BusyBox*) SED_REPLACE="sed -i ";;
    *) SED_REPLACE="sed -i '' ";;
esac

rand () {
  dd count=1 bs=2 if=/dev/urandom 2> /dev/null | od -x | awk 'NR==1{print $2}'
}

generate_config () {
  local name_type="$NAME_TYPE"
  local node_name="$NAME"

  ## Delete the *.siz files first or it cann't start after
  ## changing the config 'log.rotation.size'
  rm -rf "${RUNNER_LOG_DIR}"/*.siz

  EMQX_LICENSE_CONF_OPTION=""
  if [ "${EMQX_LICENSE_CONF:-}" != "" ]; then
      EMQX_LICENSE_CONF_OPTION="-c ${EMQX_LICENSE_CONF}"
  fi

  ## timestamp for each generation
  local NOW_TIME
  NOW_TIME="$(call_hocon now_time)"

  ## ths command populates two files: app.<time>.config and vm.<time>.args
  ## disable SC2086 to allow EMQX_LICENSE_CONF_OPTION to split
  # shellcheck disable=SC2086
  call_hocon -v -t $NOW_TIME -s $SCHEMA_MOD -c $RUNNER_ETC_DIR/emqx.conf $EMQX_LICENSE_CONF_OPTION -d $RUNNER_DATA_DIR/configs generate

  ## filenames are per-hocon convention
  RELEASE_SYS_CONFIG="$CONFIGS_DIR/app.$NOW_TIME.config"
  RELEASE_VM_ARGS="$CONFIGS_DIR/vm.$NOW_TIME.args"

  ## Merge hocon generated *.args into the vm.args
  TMP_ARG_FILE="$CONFIGS_DIR/vm.args.tmp"
  cp "$RUNNER_ETC_DIR/vm.args" "$TMP_ARG_FILE"
  echo "" >> "$TMP_ARG_FILE"
  echo "-pa ${REL_VSN_DIR}/consolidated" >> "$TMP_ARG_FILE"
  ## read lines from generated vm.<time>.args file
  ## drop comment lines, and empty lines using sed
  ## pipe the lines to a while loop
  sed '/^#/d' "$RELEASE_VM_ARGS" | sed '/^$/d' | while IFS='' read -r ARG_LINE || [ -n "$ARG_LINE" ]; do
      ## in the loop, split the 'key[:space:]value' pair
      ARG_KEY=$(echo "$ARG_LINE" | awk '{$NF="";print}')
      ARG_VALUE=$(echo "$ARG_LINE" | awk '{print $NF}')
      ## use the key to look up in vm.args file for the value
      TMP_ARG_VALUE=$(grep "^$ARG_KEY" "$TMP_ARG_FILE" || true | awk '{print $NF}')
      ## compare generated (to override) value to original (to be overriden) value
      if [ "$ARG_VALUE" != "$TMP_ARG_VALUE" ] ; then
          ## if they are different
          if [ -n "$TMP_ARG_VALUE" ]; then
              ## if the old value is present, replace it with generated value
              sh -c "$SED_REPLACE 's|^$ARG_KEY.*$|$ARG_LINE|' $TMP_ARG_FILE"
          else
              ## otherwise append generated value to the end
              echo "$ARG_LINE" >> "$TMP_ARG_FILE"
          fi
      fi
  done
  echo "$name_type $node_name" >> "$TMP_ARG_FILE"
  ## rename the generated vm.<time>.args file
  mv -f "$TMP_ARG_FILE" "$RELEASE_VM_ARGS"

 #  # # shellcheck disable=SC2086
  # if ! relx_nodetool chkconfig $CONFIG_ARGS; then
  #     die "failed_to_check_config $CONFIG_ARGS"
  # fi
}

rpc () {
  # TODO: remote vm args
  exec "$REL_VSN_DIR/elixir" \
       --hidden --cookie "$RELEASE_COOKIE" \
       --boot "$REL_VSN_DIR/$RELEASE_BOOT_SCRIPT_CLEAN" \
       --boot-var RELEASE_LIB "$RELEASE_ROOT/lib" \
       --vm-args "$RELEASE_REMOTE_VM_ARGS" \
       --rpc-eval "$RELEASE_NODE" "$1"
}

start () {
  generate_config
  REL_EXEC="$1"
  shift
  exec "$REL_VSN_DIR/$REL_EXEC" \
       --cookie "$RELEASE_COOKIE" \
       --erl "-mode $RELEASE_MODE -mnesia dir \"${MNESIA_DATA_DIR}\"" \
       --erl-config "$RELEASE_SYS_CONFIG" \
       --boot "$REL_VSN_DIR/$RELEASE_BOOT_SCRIPT" \
       --boot-var RELEASE_LIB "$RELEASE_ROOT/lib" \
       --vm-args "$RELEASE_VM_ARGS" "$@"
}

call_hocon() {
  nodetool hocon "$@"
}

nodetool () {
  command="$1"; shift
  "$RUNNER_ROOT_DIR/erts-$ERTS_VSN/bin/erl" \
      +B -noshell \
      -boot "$REL_VSN_DIR/$RELEASE_BOOT_SCRIPT_CLEAN" \
      -boot_var RELEASE_LIB "$RELEASE_ROOT/lib" \
      -run escript start \
      -extra "$RUNNER_ROOT_DIR/bin/nodetool" \
      "$command" "$@"
}

set_name "$1"

case $1 in
  start)
    start "elixir" --no-halt
    ;;

  start_iex)
    start "iex" --werl
    ;;

  daemon)
    start "elixir" --no-halt --pipe-to "${RELEASE_TMP}/pipe" "${RELEASE_TMP}/log"
    ;;

  daemon_iex)
    start "iex" --pipe-to "${RELEASE_TMP}/pipe" "${RELEASE_TMP}/log"
    ;;

  eval)
    if [ -z "$2" ]; then
      echo "ERROR: EVAL expects an expression as argument" >&2
      exit 1
    fi
    exec "$REL_VSN_DIR/elixir" \
      --cookie "$RELEASE_COOKIE" \
      --erl-config "$RELEASE_SYS_CONFIG" \
      --boot "$REL_VSN_DIR/$RELEASE_BOOT_SCRIPT_CLEAN" \
      --boot-var RELEASE_LIB "$RELEASE_ROOT/lib" \
      --vm-args "$RELEASE_VM_ARGS" --eval "$2"
    ;;

  remote)
    generate_config
    exec "$REL_VSN_DIR/iex" \
         --werl --hidden --cookie "$RELEASE_COOKIE" \
         --boot "$REL_VSN_DIR/$RELEASE_BOOT_SCRIPT_CLEAN" \
         --boot-var RELEASE_LIB "$RELEASE_ROOT/lib" \
         --vm-args "$RELEASE_REMOTE_VM_ARGS" \
         --remsh "$RELEASE_NODE"
    ;;

  rpc)
    if [ -z "$2" ]; then
      echo "ERROR: RPC expects an expression as argument" >&2
      exit 1
    fi
    rpc "$2"
    ;;

  restart|stop)
    rpc "System.$1()"
    ;;

  pid)
    rpc "IO.puts System.pid()"
    ;;

  version)
    echo "$RELEASE_NAME $RELEASE_VSN"
    ;;

  *)
    echo "Usage: $(basename "$0") COMMAND [ARGS]

The known commands are:

    start          Starts the system
    start_iex      Starts the system with IEx attached
    daemon         Starts the system as a daemon
    daemon_iex     Starts the system as a daemon with IEx attached
    eval \"EXPR\"    Executes the given expression on a new, non-booted system
    rpc \"EXPR\"     Executes the given expression remotely on the running system
    remote         Connects to the running system via a remote shell
    restart        Restarts the running system via a remote command
    stop           Stops the running system via a remote command
    pid            Prints the operating system PID of the running system via a remote command
    version        Prints the release name and version to be booted
" >&2

    if [ -n "$1" ]; then
      echo "ERROR: Unknown command $1" >&2
      exit 1
    fi
    ;;
esac
